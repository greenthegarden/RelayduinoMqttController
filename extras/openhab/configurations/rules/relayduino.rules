import org.openhab.core.library.types.*
//import org.openhab.core.library.items.*
import org.openhab.core.persistence.*
import org.openhab.model.script.actions.*

import org.joda.time.*

//import java.util.concurrent.locks.ReentrantLock
import java.util.ArrayList

var java.util.concurrent.locks.ReentrantLock lock = new java.util.concurrent.locks.ReentrantLock()

var java.util.ArrayList zonesRequestsList = new java.util.ArrayList()

// Based on code from
// https://github.com/openhab/openhab/wiki/Samples-Rules#irrigation-controller
// and
// https://github.com/openhab/openhab/wiki/AlarmClock

// consider using the caldav binding

val int Zone1_Duration_Default = 1
val int Zone2_Duration_Default = 2
val int Zone3_Max_Duration_Default = 2
val int Zone3_Volume_Default = 1000

rule "Irrigation startup"
when
	System started
then
	postUpdate(Irrigation_Master, ON)
// ensure all relays are off at startup
//	sendCommand(Irrigation_Lawn, OFF)
//	sendCommand(Irrigation_Vege, OFF)
//	sendCommand(Irrigation_Back, OFF)
//	sendCommand(Irrigation_Front, OFF)
//	sendCommand(IrrigationTreesRelay, OFF)

// initialise durations
	if (Zone1_Duration.state == Uninitialized) {
		postUpdate(Zone1_Duration, Zone1_Duration_Default)
	}
	if (Zone2_Duration.state == Uninitialized) {
		postUpdate(Zone2_Duration, Zone2_Duration_Default)
	}
	if (Zone3_Max_Duration.state == Uninitialized) {
		postUpdate(Zone3_Max_Duration, Zone3_Max_Duration_Default)
	}
	if (Zone3_Volume.state == Uninitialized) {
		postUpdate(Zone3_Volume, Zone3_Volume_Default)
	}
	if (ZonesRequestsNumber.state == Uninitialized ) {
		postUpdate(ZonesRequestsNumber, zonesRequestsList.size())
	}
end

rule "All Zones Off"
when
	Item AllZones received command OFF
then
	logInfo("relayduino", "All Zones Off")
//	sendCommand(IrrigationTreesRelay, "OFF")
	sendCommand(Zone1_RelayCtrl, OFF)
	sendCommand(Zone2_RelayCtrl, OFF)
end

rule "Irrigation Manual or Auto Request"
when
	Item Zone1_Auto received command ON or
	Item Zone1_Manual received command ON
then
	lock.lock()
    try {
		logInfo("relayduino", "Manual or automatic request to switch trees " + receivedCommand.toString())
		sendCommand(Zone1_Request, ON)
	} finally {
    	lock.unlock()
    }
end

rule "Irrigation Manual OFF"
when
	Item Zone1_Manual received command OFF
then
	lock.lock()
    try {
		logInfo("relayduino", "Manual request to switch trees " + receivedCommand.toString())
		sendCommand(Zone1_Request, OFF)
	} finally {
    	lock.unlock()
    }
end

// the scheduler ensures that if more than one irrigation request occurs at a time
// all will be actioned sequentially
rule "Irrigation Requests"
when
	Item Zone1_Request received command ON
then
	lock.lock()
    try {
		// if something else in list add to list, else startIrrigation
		logInfo("relayduino", "Zone1_Request receivedCommand: " + receivedCommand.toString())
		if (Zone1_Request.state == ON ) {
			zonesRequestsList.add("Zone1")
		}
		logInfo("relayduino", "zonesRequestsList.size() = " + zonesRequestsList.size())
		postUpdate(ZonesRequestsNumber, zonesRequestsList.size())
	} finally {
    	lock.unlock()
    }
end

rule "Irrigation End"
when
	Item Zone1_Request received command OFF
then
	lock.lock()
    try {
	//	if (receivedCommand.toString == "IrrigationRequestTrees")
		if (Zone1_Request.state == OFF) {
			zonesRequestsList.remove("Zone1")
			sendCommand(Zone1_Run, OFF)
		}
		postUpdate(ZonesRequestsNumber, zonesRequestsList.size())
	} finally {
    	lock.unlock()
	}
end

rule "Request Manager"
when
	Item ZonesRequestsNumber changed
then
	lock.lock()
    try {
		logInfo("relayduino", "IrrigationRequestsNumber = " + ZonesRequestsNumber)
		// get first zone and start irrigation
		if (zonesRequestsList.size() > 0) {
			val String zone = zonesRequestsList.get(0).toString()
			if (zone == "Zone1")
				sendCommand(Zone1_Run, ON)
		} else {
//			sendCommand(AllZones, OFF)
			sendCommand(Zone1_Run, OFF)
		}
	} finally {
    	lock.unlock()
	}
end

rule "Trees Run"
when
	Item Zone1_Run changed to ON
then
	lock.lock()
    try {
		// determine end time depending on whether manual or automatic		
		var int duration = (Zone1_Duration.state as DecimalType).intValue()
		if (Zone1_Auto.state == ON) {
			if (duration < 1) {
				duration = Zone1_Duration_Default
			}
		}
		if (duration > 0) {
			logInfo("relayduino", "duration = " + duration + " mins")
			var DateTime endTime = now.plusMinutes(duration)
			logInfo("relayduino", "endTime = " + endTime)
			// create timer to switch off irrigation
			createTimer(endTime) [|
				sendCommand(Zone1_Request, OFF)
			]
		}
	} finally {
    	lock.unlock()
	}
end

rule "Trees End"
when
	Item Zone1_Run changed to OFF
then
	lock.lock()
    try {
		// switch on irrigation
		//sendCommand(IrrigationTreesRelay, "ON")
		sendCommand(Zone1_RelayCtrl, OFF)
		if (Zone1_Auto.state==ON) {
			sendCommand(Zone1_Auto, OFF)
		}
		if (Zone1_Manual.state==ON) {
			sendCommand(Zone1_Manual, OFF)
		}
	} finally {
    	lock.unlock()
	}
end

// water trees each Saturday morning for 3 hours
rule "Schedule Zone 1"
when
	Time cron "0 0 7 ? * SAT"
then
	lock.lock()
    try {
		// switch on irrigation
		sendCommand(Zone1_Request, ON)
	} finally {
    	lock.unlock()
	}
end

rule "Schedule Zone 2"
when
	Time cron "0 0/5 * * * ?"	// for testing schedule every five minutes
then
	lock.lock()
    try {
		// switch on irrigation
		logInfo("relayduino", "Zone 2 scheduled ")
		sendCommand(Zone2_Auto, ON)
	} finally {
    	lock.unlock()
	}
end

rule "Zone 2 Auto or Manual Request"
when
	Item Zone2_Auto received command ON or
	Item Zone2_Manual received command ON
then
	lock.lock()
    try {
		logInfo("relayduino", "Manual or automatic request to switch vegetables " + receivedCommand.toString())
//		sendCommand(Zone2_Request, ON)
		sendCommand(Zone2_Run, ON)
	} finally {
    	lock.unlock()
    }
end

rule "Zone 2 Request On"
when
	Item Zone2_Request received command ON
then
	lock.lock()
    try {
		sendCommand(Zone2_Run, ON)
	} finally {
    	lock.unlock()
	}
end

rule "Zone 2 Request Off"
when
	Item Zone2_Request received command OFF
then
	lock.lock()
    try {
		sendCommand(Zone2_Run, OFF)
	} finally {
    	lock.unlock()
	}
end

rule "Zone 2 Manual OFF"
when
	Item Zone2_Manual received command OFF
then
	lock.lock()
    try {
		logInfo("relayduino", "Manual request to switch zone 2 " + receivedCommand.toString())
//		sendCommand(Zone2_Request, OFF)
		sendCommand(Zone2_Run, OFF)
	} finally {
    	lock.unlock()
    }
end

rule "Zone 2 Run"
when
	Item Zone2_Run changed to ON
then
	lock.lock()
    try {
		// get start time to nearest minute
//		var DateTime startTime = parse(now.getYear() + "-" + now.getMonthOfYear() + "-" + now.getDayOfMonth() + "T" + now.getHourOfDay() + ":" + now.getMinuteOfDay())
//		logInfo("relayduino", "startTime = " + startTime)
		// determine end time depending on whether manual or automatic		
		var int duration = (Zone2_Duration.state as DecimalType).intValue()
		logInfo("relayduino", "duration = " + duration + " mins")
//		var DateTime endTime = startTime.plusMinutes(duration)			
		var DateTime endTime = now.plusMinutes(duration)			
		logInfo("relayduino", "endTime = " + endTime)
		
		// switch on zone
//		createTimer(startTime) [|
			sendCommand(Zone2_RelayCtrl, ON)
//		]
		
		// create timer to switch off irrigation
		createTimer(endTime) [|
			sendCommand(Zone2_Run, OFF)
		]
	} finally {
    	lock.unlock()
	}
end

rule "Zone 2 Stop"
when
	Item Zone2_Run changed to OFF
then
	lock.lock()
    try {
		// switch on zone
		sendCommand(Zone2_RelayCtrl, OFF)
		if (Zone2_Manual.state == ON) {
			sendCommand(Zone2_Manual, OFF)
		}
		if (Zone2_Auto.state == ON) {
			sendCommand(Zone2_Auto, OFF)
		}
	} finally {
    	lock.unlock()
	}
end


rule "Schedule Zone 3"
when
	Time cron "0 0/5 * * * ?"	// for testing schedule every five minutes
then
	lock.lock()
    try {
		// switch on irrigation
		logInfo("relayduino", "Zone 3 scheduled ")
		sendCommand(Zone3_Auto, ON)
	} finally {
    	lock.unlock()
	}
end

rule "Zone 3 Auto or Manual Request"
when
	Item Zone3_Auto received command ON or
	Item Zone3_Manual received command ON
then
	lock.lock()
    try {
		logInfo("relayduino", "Manual or automatic request to switch vegetables " + receivedCommand.toString())
//		sendCommand(Zone3_Request, ON)
		sendCommand(Zone3_Run, ON)
	} finally {
    	lock.unlock()
    }
end

rule "Zone 3 Request On"
when
	Item Zone3_Request received command ON
then
	lock.lock()
    try {
		sendCommand(Zone3_Run, ON)
	} finally {
    	lock.unlock()
	}
end

rule "Zone 3 Request Off"
when
	Item Zone3_Request received command OFF
then
	lock.lock()
    try {
		sendCommand(Zone3_Run, OFF)
	} finally {
    	lock.unlock()
	}
end

rule "Zone 3 Manual OFF"
when
	Item Zone3_Manual received command OFF
then
	lock.lock()
    try {
		logInfo("relayduino", "Manual request to switch zone 3 " + receivedCommand.toString())
//		sendCommand(Zone3_Request, OFF)
		sendCommand(Zone3_Run, OFF)
	} finally {
    	lock.unlock()
    }
end

rule "Zone 3 Run"
when
	Item Zone3_Run changed to ON
then
	lock.lock()
    try {
		var int duration = (Zone3_Max_Duration.state as DecimalType).intValue()
		logInfo("relayduino", "duration = " + duration + " mins")
		var DateTime endTime = now.plusMinutes(duration)			
		logInfo("relayduino", "endTime = " + endTime)
		sendCommand(Zone3_RelayCtrl, ON)
		// create timer to switch off irrigation
		createTimer(endTime) [|
			sendCommand(Zone3_Run, OFF)
		]
		// need to be able to switch off when volume exceeded
	} finally {
    	lock.unlock()
	}
end

rule "Zone 3 Stop"
when
	Item Zone3_Run changed to OFF
then
	lock.lock()
    try {
		// switch on zone
		sendCommand(Zone3_RelayCtrl, OFF)
		if (Zone3_Manual.state == ON) {
			sendCommand(Zone3_Manual, OFF)
		}
		if (Zone3_Auto.state == ON) {
			sendCommand(Zone3_Auto, OFF)
		}
	} finally {
    	lock.unlock()
	}
end

//rule "Irrigation run"
//when
//	Time cron "0 0 0 * * ?"
//then
//	if (Irrigation_Master.state == ON) {
//	// get the scale factor - used to reduce the run times across the board
//	var Number scaleFactor = Irrigation_ScaleFactor.state as DecimalType
//
//	// convert our start time to a joda.time.DateTime for today
//	var DateTime startTime = parse(now.getYear() + "-" + now.getMonthOfYear() + "-" + now.getDayOfMonth() + "T" + Irrigation_StartTime.state + ":00")
//	var DateTime endTime
//
//	// get the raw run times for each zone (in mins)
//	var Number lawnMins = Irrigation_LawnMins.state as DecimalType
//	var Number vegeMins = Irrigation_VegeMins.state as DecimalType
//	var Number backMins = Irrigation_BackMins.state as DecimalType
//	var Number frontMins = Irrigation_FrontMins.state as DecimalType
//
//	// convert to the actual run times (by applying the scale factor)
//	var int lawnTime = ((lawnMins * scaleFactor) / 100).intValue
//	var int vegeTime = ((vegeMins * scaleFactor) / 100).intValue
//	var int backTime = ((backMins * scaleFactor) / 100).intValue
//	var int frontTime = ((frontMins * scaleFactor) / 100).intValue
//
//	// turn on each zone in turn (with a minute gap between each zone activation)
//	if (lawnTime > 0) {
//		endTime = startTime.plusMinutes(lawnTime)
//		createTimer(startTime) [| sendCommand(Irrigation_Lawn, ON) ]
//		createTimer(endTime) [| sendCommand(Irrigation_Lawn, OFF) ]
//		startTime = endTime.plusMinutes(1)
//	}
//
//	if (vegeTime > 0) {
//		endTime = startTime.plusMinutes(vegeTime)
//		createTimer(startTime) [| sendCommand(Irrigation_Vege, ON) ]
//		createTimer(endTime) [| sendCommand(Irrigation_Vege, OFF) ]
//		startTime = endTime.plusMinutes(1)
//	}
//
//            if (backTime > 0) {
//                endTime = startTime.plusMinutes(backTime)
//                createTimer(startTime) [| sendCommand(Irrigation_Back, ON) ]
//                createTimer(endTime) [| sendCommand(Irrigation_Back, OFF) ]
//                startTime = endTime.plusMinutes(1)
//            }
//
//            if (frontTime > 0) {
//                endTime = startTime.plusMinutes(frontTime)
//                createTimer(startTime) [| sendCommand(Irrigation_Front, ON) ]
//                createTimer(endTime) [| sendCommand(Irrigation_Front, OFF) ]
//                startTime = endTime.plusMinutes(1)
//            }
//        }
//    end

rule "Disable irrigation if any rain"
when
	Item Weather_Rain changed or
	Item Weather_TodayIcon changed or
	Item Weather_TomorrowIcon changed
then
	// the rainfall threshold where we shutdown off irrigation
	var rainThreshold = 1

	// check for any rain in the last 24 hours
	var rainInLast24Hours = Weather_Rain.maximumSince(now.minusHours(24), "rrd4j")

	// default to the current rain value in case there is nothing in our history
	var rain = Weather_Rain.state

	if (rainInLast24Hours != null)
		rain = rainInLast24Hours.state

	// check if any rain is forecast
	var rainToday = Weather_TodayIcon.state == "chanceflurries" ||
                        Weather_TodayIcon.state == "chancerain" ||
                        Weather_TodayIcon.state == "chancesleet" ||
                        Weather_TodayIcon.state == "chancesnow" ||
                        Weather_TodayIcon.state == "chancetstorms" ||
                        Weather_TodayIcon.state == "flurries" ||
                        Weather_TodayIcon.state == "rain" ||
                        Weather_TodayIcon.state == "sleet" ||
                        Weather_TodayIcon.state == "snow" ||
                        Weather_TodayIcon.state == "tstorms"

	var rainTomorrow = Weather_TomorrowIcon.state == "chanceflurries" ||
                           Weather_TomorrowIcon.state == "chancerain" ||
                           Weather_TomorrowIcon.state == "chancesleet" ||
                           Weather_TomorrowIcon.state == "chancesnow" ||
                           Weather_TomorrowIcon.state == "chancetstorms" ||
                           Weather_TomorrowIcon.state == "flurries" ||
                           Weather_TomorrowIcon.state == "rain" ||
                           Weather_TomorrowIcon.state == "sleet" ||
                           Weather_TomorrowIcon.state == "snow" ||
                           Weather_TomorrowIcon.state == "tstorms"

	// shutoff irrigation if there has been rain or rain is forecast
	var logMessage = ""
	if (rain > rainThreshold) {
		logMessage = "Rain in the last 24 hours (" + rain + " mm) is above our threshold (" + rainThreshold + " mm) - irrigation disabled!"
	} else if (rainToday) {
		logMessage = "Rain is forecast for today - irrigation disabled!"
	} else if (rainTomorrow) {
		logMessage = "Rain is forecast for tomorrow - irrigation disabled!"
	}

	if (logMessage != "") {
		if (Irrigation_Master.state == ON) {
			logInfo("Irrigation", logMessage)
			//send("ben.jones12@gmail.com", logMessage)
			postUpdate(Irrigation_Master, OFF)
		}
	} else {
		if (Irrigation_Master.state == OFF) {
			logInfo("Irrigation", "No rain in the last 24 hours or any rain forecast - irrigation enabled!")
			//send("ben.jones12@gmail.com", "No rain in the last 24 hours or any rain forecast - irrigation enabled!")
			postUpdate(Irrigation_Master, ON)
		}
	}
end
