import org.openhab.core.library.types.*
//import org.openhab.core.library.items.*
import org.openhab.core.persistence.*
import org.openhab.model.script.actions.*

import org.joda.time.*

//import java.util.concurrent.locks.ReentrantLock
import java.util.ArrayList

//var java.util.concurrent.locks.ReentrantLock lock1 = new java.util.concurrent.locks.ReentrantLock()

var java.util.ArrayList irrigationRequests = new java.util.ArrayList()

// Based on code from
// https://github.com/openhab/openhab/wiki/Samples-Rules#irrigation-controller
// and
// https://github.com/openhab/openhab/wiki/AlarmClock

// consider using the caldav binding

val TreesMins_default = 1

rule "Irrigation startup"
when
	System started
then
	postUpdate(Irrigation_Master, ON)
// ensure all relays are off at startup
//	sendCommand(Irrigation_Lawn, OFF)
//	sendCommand(Irrigation_Vege, OFF)
//	sendCommand(Irrigation_Back, OFF)
//	sendCommand(Irrigation_Front, OFF)
//	sendCommand(IrrigationTreesRelay, OFF)

// initialise durations
	if (Irrigation_TreesMins.state == Uninitialized) {
		postUpdate(Irrigation_TreesMins, 1)
//		postUpdate(Irrigation_TreesMins, TreesMins_default)
	}
	if (IrrigationRequestsNumber.state == Uninitialized ) {
			postUpdate(IrrigationRequestsNumber, irrigationRequests.size())
	}
end

rule "All Zones Off"
when
	Item AllZones received command OFF
then
	logInfo("relayduino", "All Zones Off")
//	sendCommand(IrrigationTreesRelay, "OFF")
	sendCommand(IrrigationTreesRelay, OFF)
end

rule "Irrigation Manual or Auto Request"
when
	Item IrrigationRequestAutoTrees received command ON or
	Item IrrigationRequestManualTrees received command ON
then
	logInfo("relayduino", "Manual or automatic request to switch trees " + receivedCommand.toString())
	sendCommand(IrrigationRequestTrees, ON)
end

rule "Irrigation Manual OFF"
when
	Item IrrigationRequestManualTrees received command OFF
then
	logInfo("relayduino", "Manual request to switch trees " + receivedCommand.toString())
	sendCommand(IrrigationRequestTrees, OFF)
end

// the scheduler ensures that if more than one irrigation request occurs at a time
// all will be actioned sequentially
rule "Irrigation Requests"
when
	Item IrrigationRequestTrees received command ON
then
	// if something else in list add to list, else startIrrigation
	logInfo("relayduino", "IrrigationRequestTrees receivedCommand: " + receivedCommand.toString())
	if (IrrigationRequestTrees.state == ON ) {
		irrigationRequests.add("Trees")
	}
	logInfo("relayduino", "irrigationRequests.size() = " + irrigationRequests.size())
	postUpdate(IrrigationRequestsNumber, irrigationRequests.size())
end

rule "Irrigation Start"
when
	Item IrrigationRequestsNumber changed
then
	logInfo("relayduino", "IrrigationRequestsNumber = " + IrrigationRequestsNumber)
	// get first zone and start irrigation
	if (irrigationRequests.size() > 0) {
		val String zone = irrigationRequests.get(0).toString()
		if (zone == "Trees")
			sendCommand(IrrigationTreesStart, ON)
	} else {
		sendCommand(AllZones, OFF)
		sendCommand(IrrigationTreesStart, OFF)
	}
end

rule "Irrigation End"
when
	Item IrrigationRequestTrees received command OFF
then
//	if (receivedCommand.toString == "IrrigationRequestTrees")
	if (IrrigationRequestTrees.state == OFF) {
		irrigationRequests.remove("Trees")
		sendCommand(IrrigationTreesRelay, OFF)
		sendCommand(IrrigationTreesStart, OFF)
	}
	postUpdate(IrrigationRequestsNumber, irrigationRequests.size())
end

// water trees each Saturday morning for 3 hours
rule "Trees Start"
when
	Item IrrigationTreesStart changed to ON
then
	// switch on irrigation
	//sendCommand(IrrigationTreesRelay, "ON")
	sendCommand(IrrigationTreesRelay, ON)

	// get start time to nearest minute
	var DateTime startTime = parse(now.getYear() + "-" + now.getMonthOfYear() + "-" + now.getDayOfMonth() + "T" + now.getHourOfDay() + ":00")

	// determine end time
	var int duration = (Irrigation_TreesMins.state as DecimalType).intValue()
	var DateTime endTime = startTime.plusMinutes(duration)

	// create time to switch off irrigation
	//createTimer(endTime) [| sendCommand(IrrigationTreesRelay, "OFF") ]
	createTimer(endTime) [|
		sendCommand(IrrigationRequestTrees, OFF)
	]
end

// water trees each Saturday morning for 3 hours
rule "Schedule Water Trees"
when
	Time cron "0 0 7 ? * SAT"
then
	// switch on irrigation
	sendCommand(IrrigationRequestTrees, ON)
end


//rule "Irrigation run"
//when
//	Time cron "0 0 0 * * ?"
//then
//	if (Irrigation_Master.state == ON) {
//	// get the scale factor - used to reduce the run times across the board
//	var Number scaleFactor = Irrigation_ScaleFactor.state as DecimalType
//
//	// convert our start time to a joda.time.DateTime for today
//	var DateTime startTime = parse(now.getYear() + "-" + now.getMonthOfYear() + "-" + now.getDayOfMonth() + "T" + Irrigation_StartTime.state + ":00")
//	var DateTime endTime
//
//	// get the raw run times for each zone (in mins)
//	var Number lawnMins = Irrigation_LawnMins.state as DecimalType
//	var Number vegeMins = Irrigation_VegeMins.state as DecimalType
//	var Number backMins = Irrigation_BackMins.state as DecimalType
//	var Number frontMins = Irrigation_FrontMins.state as DecimalType
//
//	// convert to the actual run times (by applying the scale factor)
//	var int lawnTime = ((lawnMins * scaleFactor) / 100).intValue
//	var int vegeTime = ((vegeMins * scaleFactor) / 100).intValue
//	var int backTime = ((backMins * scaleFactor) / 100).intValue
//	var int frontTime = ((frontMins * scaleFactor) / 100).intValue
//
//	// turn on each zone in turn (with a minute gap between each zone activation)
//	if (lawnTime > 0) {
//		endTime = startTime.plusMinutes(lawnTime)
//		createTimer(startTime) [| sendCommand(Irrigation_Lawn, ON) ]
//		createTimer(endTime) [| sendCommand(Irrigation_Lawn, OFF) ]
//		startTime = endTime.plusMinutes(1)
//	}
//
//	if (vegeTime > 0) {
//		endTime = startTime.plusMinutes(vegeTime)
//		createTimer(startTime) [| sendCommand(Irrigation_Vege, ON) ]
//		createTimer(endTime) [| sendCommand(Irrigation_Vege, OFF) ]
//		startTime = endTime.plusMinutes(1)
//	}
//
//            if (backTime > 0) {
//                endTime = startTime.plusMinutes(backTime)
//                createTimer(startTime) [| sendCommand(Irrigation_Back, ON) ]
//                createTimer(endTime) [| sendCommand(Irrigation_Back, OFF) ]
//                startTime = endTime.plusMinutes(1)
//            }
//
//            if (frontTime > 0) {
//                endTime = startTime.plusMinutes(frontTime)
//                createTimer(startTime) [| sendCommand(Irrigation_Front, ON) ]
//                createTimer(endTime) [| sendCommand(Irrigation_Front, OFF) ]
//                startTime = endTime.plusMinutes(1)
//            }
//        }
//    end

rule "Disable irrigation if any rain"
when
	Item Weather_Rain changed or
	Item Weather_TodayIcon changed or
	Item Weather_TomorrowIcon changed
then
	// the rainfall threshold where we shutdown off irrigation
	var rainThreshold = 1

	// check for any rain in the last 24 hours
	var rainInLast24Hours = Weather_Rain.maximumSince(now.minusHours(24), "rrd4j")

	// default to the current rain value in case there is nothing in our history
	var rain = Weather_Rain.state

	if (rainInLast24Hours != null)
		rain = rainInLast24Hours.state

	// check if any rain is forecast
	var rainToday = Weather_TodayIcon.state == "chanceflurries" ||
                        Weather_TodayIcon.state == "chancerain" ||
                        Weather_TodayIcon.state == "chancesleet" ||
                        Weather_TodayIcon.state == "chancesnow" ||
                        Weather_TodayIcon.state == "chancetstorms" ||
                        Weather_TodayIcon.state == "flurries" ||
                        Weather_TodayIcon.state == "rain" ||
                        Weather_TodayIcon.state == "sleet" ||
                        Weather_TodayIcon.state == "snow" ||
                        Weather_TodayIcon.state == "tstorms"

	var rainTomorrow = Weather_TomorrowIcon.state == "chanceflurries" ||
                           Weather_TomorrowIcon.state == "chancerain" ||
                           Weather_TomorrowIcon.state == "chancesleet" ||
                           Weather_TomorrowIcon.state == "chancesnow" ||
                           Weather_TomorrowIcon.state == "chancetstorms" ||
                           Weather_TomorrowIcon.state == "flurries" ||
                           Weather_TomorrowIcon.state == "rain" ||
                           Weather_TomorrowIcon.state == "sleet" ||
                           Weather_TomorrowIcon.state == "snow" ||
                           Weather_TomorrowIcon.state == "tstorms"

	// shutoff irrigation if there has been rain or rain is forecast
	var logMessage = ""
	if (rain > rainThreshold) {
		logMessage = "Rain in the last 24 hours (" + rain + " mm) is above our threshold (" + rainThreshold + " mm) - irrigation disabled!"
	} else if (rainToday) {
		logMessage = "Rain is forecast for today - irrigation disabled!"
	} else if (rainTomorrow) {
		logMessage = "Rain is forecast for tomorrow - irrigation disabled!"
	}

	if (logMessage != "") {
		if (Irrigation_Master.state == ON) {
			logInfo("Irrigation", logMessage)
			//send("ben.jones12@gmail.com", logMessage)
			postUpdate(Irrigation_Master, OFF)
		}
	} else {
		if (Irrigation_Master.state == OFF) {
			logInfo("Irrigation", "No rain in the last 24 hours or any rain forecast - irrigation enabled!")
			//send("ben.jones12@gmail.com", "No rain in the last 24 hours or any rain forecast - irrigation enabled!")
			postUpdate(Irrigation_Master, ON)
		}
	}
end
